'reach 0.1';

const Player = {
  ...hasRandom, // <--- new!
  ...hasConsoleLogger,
  getHand: Fun([], UInt),
  seeOutcome: Fun([UInt], Null),
};

const [isHand, ROCK, PAPER, SCISSORS] = makeEnum(3);
const [isOutcome, B_WINS, DRAW, A_WINS] = makeEnum(3);
/*
An enumeration (or enum, for short), can be created by calling the makeEnum function, 
as in makeEnum(N), where N is the number of distinct values in the enum. 
where the first value is a Fun([UInt], Bool) which tells you if its ARGUMENT is one of the enum's values, 
and the next N values are distinct UInts

const [ isOutcome, LENDER_TIMEOUT, BORROWER_TIMEOUT ] = makeEnum(2);
isOutcome is a function that takes a UInt and returns true or false depending on 
if the UInt passed to it is a MEMBER of that enumeration or not. 
---LENDER_TIMEOUT, BORROWER_TIMEOUT  are UInts
So isOutcome(LENDER_TIMEOUT) would return true while isOutcome(SCISSORS) would return false.217
*/

const winner = (handAlice, handBob) => ((handAlice + (4 - handBob)) % 3);

// winner (A_hand, B_hand)--> see previous line
assert(winner(ROCK, PAPER) == B_WINS);
assert(winner(PAPER, ROCK) == A_WINS);

// whenever the same value is provided for both hands, winner return DRAW
assert(winner(ROCK, ROCK) == DRAW);

forall(UInt, handAlice =>
  forall(UInt, handBob =>
    assert(isOutcome(winner(handAlice, handBob)))));

// always DRAW, as hand== hand, hand is test parameter generated by verification engine
forall(UInt, (hand) =>
  assert(winner(hand, hand) == DRAW));

export const main = Reach.App(() => {
  const A = Participant('Alice', {
    ...Player,
    wager: UInt,
  });

  const B = Participant('Bob', {
    ...Player,
    acceptWager: Fun([UInt], Null),
  });

  init();

  A.only(()=>{
    // declassify make Alice shares the wager amount with Bob
    const wager = declassify(interact.wager);

    // new: Alice compute her hand, but not declassify it.
    const _handAlice = interact.getHand();

    // commit phase
    const [_commitAlice, _saltAlice] = makeCommitment(interact, _handAlice); //interact== Participant
    /*
    Interactions in a commitment scheme take place in two phases:
    the commit phase - during which a value is chosen and committed to
    the reveal phase - during which the value is revealed by the sender, then the receiver verifies its authenticity

    so salt is the locked box/ key here
    */

    // share to receiver
    const commitAlice = declassify(_commitAlice);

  });

  A.publish(wager, commitAlice).pay(wager);
  commit();

  unknowable(B, A(_handAlice, _saltAlice));  
  /* 
  A knowledge assertion that the participant Notter(B) does not know the results of the 
  variables var_0 through var_N, but that the participant Knower(A) does know those values.
  unknowable( Notter, Knower(var_0, ..., var_N), [msg] ) 
  - checks that both Alice's hand and salt are unknowable to ensure Bob cannot cheat
 */
  B.only(()=>{
    interact.acceptWager(wager);
    const handBob = declassify(interact.getHand());
  })
  
  B.publish(handBob).pay(wager);
  commit();

  A.only(() => {
    const saltAlice = declassify(_saltAlice);
    const handAlice = declassify(_handAlice);
  });
  
  // reveal phase
  A.publish(saltAlice, handAlice);
  checkCommitment(commitAlice, saltAlice, handAlice);

  const outcome = winner(handAlice, handBob);
  const [forAlice, forBob] =
    outcome == A_WINS ? [2, 0] :
      outcome == B_WINS ? [0, 2] :
    /* tie           */[1, 1];
  
  transfer(forAlice * wager).to(A); // multiply the ratio
  transfer(forBob * wager).to(B);
  commit();
  
  each([A, B], () => {
    interact.seeOutcome(outcome);
  });

  exit();
});
